//go:build ignore
// +build ignore

// Use ../generate.go to run this.

package main

import (
	"bufio"
	"fmt"
	"github.com/zzwx/current"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
)

const packageLocation = ".."
const generatedFileName = "terminal_generated.go"
const fromFileName = "terminal_funcs.go"

// main generates methods for Terminal from
// pure functions returning string, located at fromFileName
// of the terminal package.
func main() {
	cp := current.NewPath()
	subPackage := cp.Join(packageLocation)
	fileNameWithPath := cp.Join(packageLocation, generatedFileName)
	err := RemoveFile(fileNameWithPath)
	if err != nil && !os.IsNotExist(err) {
		log.Fatalf("File deletion failed: %v", err)
	}
	f, err := os.Create(fileNameWithPath)
	if err != nil {
		log.Fatalf("File creation failed: %v", err)
	}
	defer f.Close()
	writer := bufio.NewWriter(f)
	defer writer.Flush()

	set := token.NewFileSet()
	packs, err := parser.ParseDir(set, subPackage, func(info fs.FileInfo) bool {
		return info.Name() == fromFileName
	}, parser.ParseComments)
	if err != nil {
		fmt.Println("Failed to parse package:", err)
		os.Exit(1)
	}

	fmt.Fprintf(writer, "// Code generated by internal/generate.go; DO NOT EDIT.\n\n")
	fmt.Fprintf(writer, "package terminal\n\n")

	var funcs []*ast.FuncDecl
	skip := true
	for _, pack := range packs {
		for _, f := range pack.Files {
			if f.Name.Name != "terminal" {
				continue
			}
			for _, d := range f.Decls {
				if fn, isFn := d.(*ast.FuncDecl); isFn {
					if fn.Type.Results != nil {
						if len(fn.Type.Results.List) == 1 && fmt.Sprintf("%v", fn.Type.Results.List[0].Type) == "string" {
							if !skip {
								fmt.Fprintf(writer, "\n")
							}
							skip = false
							if fn.Doc != nil {
								for _, comment := range fn.Doc.List {
									fmt.Fprintf(writer, "%v\n", comment.Text)
								}
							}
							fmt.Fprintf(writer, "func (t *Terminal) %v(", fn.Name)
							for i, field := range fn.Type.Params.List {
								if i > 0 {
									fmt.Fprintf(writer, ", ")
								}
								names := ""
								for j, name := range field.Names {
									if j > 0 {
										names += ", "
									}
									names += name.Name
								}
								fmt.Fprintf(writer, "%v %v", names, field.Type)
							}
							fmt.Fprintf(writer, ") *Terminal {\n")
							fmt.Fprintf(writer, "\tt.Print(%v(", fn.Name)
							names := ""
							for _, field := range fn.Type.Params.List {
								for _, name := range field.Names {
									if names != "" {
										names += ", "
									}
									names += name.Name
								}
							}
							fmt.Fprintf(writer, "%v))\n", names)
							fmt.Fprintf(writer, "\treturn t\n")
							fmt.Fprintf(writer, "}\n")
						}
					}
					funcs = append(funcs, fn)
				}
			}
		}
	}
	//SetReadOnly(fileNameWithPath)
}

func RemoveFile(filepath string) error {
	return os.Remove(filepath)
}

func SetReadOnly(filepath string) error {
	err := os.Chmod(filepath, 0444)
	return err
}
